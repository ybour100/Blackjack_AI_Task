<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blackjack AI Task</title>

  <!-- LZString Compression -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <style>
    :root{
      --border:#e5e5e5;
      --muted:#5a5a5a;
      --bg:#ffffff;
      --panel:#fafafa;
      --radius:14px;
      --pad:14px;
    }
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); }
    .wrap{ max-width: 860px; margin: 0 auto; padding: 18px; }
    h1{ margin: 0 0 8px; font-size: 26px; }
    h2{ margin: 0 0 10px; font-size: 20px; }
    .muted{ color:var(--muted); }
    .card{
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      background: var(--panel);
      margin: 12px 0;
    }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 1 1 auto; }
    input, select, button, textarea{ font-size: 16px; }
    input, select{
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
    }
    button{
      padding:10px 14px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      cursor:pointer;
    }
    button.primary{ background:#111; color:#fff; border-color:#111; }
    button:disabled{ opacity:0.55; cursor:not-allowed; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .hand{ font-size: 20px; letter-spacing: 0.3px; }
    .pill{
      display:inline-block;
      padding:4px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:#fff;
      font-size: 14px;
      color: var(--muted);
      margin-left: 8px;
    }
    .result{
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      background: #fff;
      font-size: 15px;
      margin-top: 10px;
    }
    .result.win{ border-color:#b7e2c3; background:#f2fbf5; }
    .result.loss{ border-color:#f0b9b9; background:#fff4f4; }
    .result.push{ border-color:#d6d6d6; background:#f7f7f7; }
    textarea{ width:100%; height: 190px; padding: 12px; border:1px solid var(--border); border-radius: 12px; background:#fff; }
    code{ background:#f2f2f2; padding:2px 6px; border-radius: 8px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    ul { margin: 10px 0 0 20px; }
    li { margin: 6px 0; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Blackjack AI Task</h1>
  <p class="muted">No data are uploaded from this page. At the end you will copy a data package back into Experimentum.</p>
  <div id="screen"></div>
</div>

<script>
/* -------------------------
   Utilities
------------------------- */
function qs(name){
  const u = new URL(window.location.href);
  return u.searchParams.get(name);
}
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function makeRng(seedStr){
  const seedFn = xmur3(seedStr);
  return mulberry32(seedFn());
}
function b64encode(str){
  return btoa(unescape(encodeURIComponent(str)));
}
function completionCodeFrom(id){
  let h = 0;
  for (let i=0; i<id.length; i++) h = (h*31 + id.charCodeAt(i)) >>> 0;
  return "UofG-" + (h.toString(16).toUpperCase()).slice(0,8);
}
function render(html){
  document.getElementById("screen").innerHTML = html;
}
function escapeHtml(s){
  return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

/* -------------------------
   Blackjack (simplified)
------------------------- */
const SUITS = ["♠","♥","♦","♣"];
const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const RANK_VALUE = {A:11,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,J:10,Q:10,K:10};

function makeShoe(decks=4){
  const shoe = [];
  for (let d = 0; d < decks; d++){
    for (const s of SUITS){
      for (const r of RANKS){
        shoe.push({r,s});
      }
    }
  }
  return shoe;
}
function shuffle(arr, rng){
  for (let i=arr.length-1;i>0;i--){
    const j = Math.floor(rng()* (i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}
function cardStr(c){ return `${c.r}${c.s}`; }
function handStr(h){ return h.map(cardStr).join(" "); }

function handTotal(hand){
  let total = 0, aces = 0;
  for (const c of hand){
    total += RANK_VALUE[c.r];
    if (c.r === "A") aces++;
  }
  while (total > 21 && aces > 0){
    total -= 10;
    aces--;
  }
  return total;
}
function isBlackjack(hand){ return hand.length===2 && handTotal(hand)===21; }

function dealerPlay(dealer, shoe){
  while (handTotal(dealer) < 17){
    dealer.push(shoe.pop());
  }
  return dealer;
}
function resolveOutcome(player, dealer, bet){
  const pBJ = isBlackjack(player), dBJ = isBlackjack(dealer);
  if (pBJ && !dBJ) return { outcome:"PLAYER_BLACKJACK", delta: Math.round(1.5*bet) };
  if (dBJ && !pBJ) return { outcome:"DEALER_BLACKJACK", delta: -bet };

  const p = handTotal(player), d = handTotal(dealer);
  if (p > 21) return { outcome:"PLAYER_BUST", delta:-bet };
  if (d > 21) return { outcome:"DEALER_BUST", delta: bet };
  if (p > d) return { outcome:"PLAYER_WIN", delta: bet };
  if (p < d) return { outcome:"DEALER_WIN", delta:-bet };
  return { outcome:"PUSH", delta:0 };
}

/* -------------------------
   AI (safe vs risky)
------------------------- */
function dealerUpValue(rank){ return rank==="A" ? 11 : RANK_VALUE[rank]; }

function basicStrategy(player, dealerUpRank){
  const total = handTotal(player);
  const dealerVal = dealerUpValue(dealerUpRank);
  const twoCards = (player.length===2);
  const hasAce = player.some(c=>c.r==="A");
  const rawTotal = player.reduce((a,c)=>a+RANK_VALUE[c.r],0);
  const soft = hasAce && rawTotal === total;

  if (!soft){
    if (total <= 8) return "Hit";
    if (total === 9)  return (twoCards && dealerVal>=3 && dealerVal<=6) ? "Double" : "Hit";
    if (total === 10) return (twoCards && dealerVal<=9) ? "Double" : "Hit";
    if (total === 11) return twoCards ? "Double" : "Hit";
    if (total === 12) return (dealerVal>=4 && dealerVal<=6) ? "Stand" : "Hit";
    if (total >= 13 && total <= 16) return (dealerVal>=2 && dealerVal<=6) ? "Stand" : "Hit";
    return "Stand";
  } else {
    if (total <= 17) return "Hit";
    if (total === 18) return (twoCards && dealerVal>=3 && dealerVal<=6) ? "Double" : (dealerVal===2||dealerVal===7||dealerVal===8 ? "Stand" : "Hit");
    return "Stand";
  }
}
function riskyDeviation(player, dealerUpRank, baseAction, rng){
  const total = handTotal(player);
  const dealerVal = dealerUpValue(dealerUpRank);
  const hasAce = player.some(c=>c.r==="A");
  const rawTotal = player.reduce((a,c)=>a+RANK_VALUE[c.r],0);
  const soft = hasAce && rawTotal === total;
  const twoCards = (player.length===2);

  if (baseAction === "Hit") return "Hit";
  if (!soft && total>=12 && total<=16 && dealerVal>=2 && dealerVal<=6){
    if (rng() < 0.35) return "Hit";
  }
  if (twoCards && baseAction !== "Double"){
    if (!soft && total===9 && dealerVal===2 && rng() < 0.35) return "Double";
    if (!soft && total===8 && dealerVal>=5 && dealerVal<=6 && rng() < 0.25) return "Double";
  }
  return baseAction;
}
function aiBet(bankroll, aiType, rng){
  if (bankroll<=0) return 0;
  const frac = (aiType==="SAFE") ? (0.05 + rng()*0.10) : (0.30 + rng()*0.20);
  return Math.max(1, Math.min(bankroll, Math.round(bankroll*frac)));
}

/* -------------------------
   Experiment state
------------------------- */
const START_BANKROLL = 100;
const ROUNDS_PER_BLOCK = 20;

// Baseline trust prompt (must still start with "Baseline" for routing)
const BASELINE_TRUST_PROMPT =
  "Before you see any advice in this task, how much would you trust an AI to guide your decisions in a game like this?";

let state = {
  pid: null,
  rng: null,
  shoe: null,

  bankroll: START_BANKROLL,
  order: ["SAFE","RISKY"],
  block: 0,        // 0 or 1
  round: 0,        // 0..ROUNDS_PER_BLOCK-1 within current block

  logs: [],
  trust: [],

  // per-round scratch for REAL task
  pending: null,

  // practice
  practiceDone: false,
  practiceRng: null,
  practiceShoe: null,
  practiceBankroll: 30
};

function counterbalance(pid){
  const digits = (pid.match(/\d/g) || []);
  if (digits.length){
    return (parseInt(digits[digits.length-1],10) % 2 === 0) ? ["SAFE","RISKY"] : ["RISKY","SAFE"];
  }
  return ["SAFE","RISKY"];
}
function draw(){
  if (state.shoe.length < 60) state.shoe = shuffle(makeShoe(4), state.rng);
  return state.shoe.pop();
}

/* -------------------------
   UI helpers
------------------------- */
function headerHTML(){
  const aiType = state.order[state.block];
  const roundDisplay = state.round + 1;
  return `
    <div class="card" style="background:#fff;">
      <div class="row" style="align-items:flex-end;">
        <div>
          <div><strong>Block</strong> ${state.block+1}/2 <span class="pill">${aiType} AI</span></div>
          <div class="muted"><strong>Round</strong> ${roundDisplay}/${ROUNDS_PER_BLOCK}</div>
        </div>
        <div style="text-align:right;">
          <div><strong>Bankroll:</strong> ${state.bankroll}</div>
        </div>
      </div>
    </div>
  `;
}

function screenFeedback(r, onContinue){
  render(`
    <div class="card" style="background:#fff;">
      <h2>${escapeHtml(r.heading || "Result")}</h2>

      <div class="result ${r.kind}">
        <div>
          <strong>${r.kind === "win" ? "You won" : (r.kind === "loss" ? "You lost" : "Push")}</strong>
          — ${escapeHtml(r.moneyText)}
        </div>
        <div class="muted" style="margin-top:6px;">
          You: <span class="mono">${escapeHtml(r.playerHand)}</span> (total ${r.playerTotal})
          <br/>
          Dealer: <span class="mono">${escapeHtml(r.dealerHand)}</span> (total ${r.dealerTotal})
        </div>
        ${r.note ? `<div class="muted" style="margin-top:8px;">${escapeHtml(r.note)}</div>` : ``}
      </div>

      <div style="margin-top:12px;">
        <button class="primary" id="continueResult">Continue</button>
      </div>
    </div>
  `);

  document.getElementById("continueResult").onclick = () => onContinue();
}

/* -------------------------
   Screens
------------------------- */
function screenStart(){
  const urlPid = qs("id") || "";
  render(`
    <div class="card">
      <h2>Participant Code</h2>
      <p class="muted">Enter the same participant code you used on Experimentum.</p>
      <div class="row">
        <input id="pid" value="${escapeHtml(urlPid)}" placeholder="e.g., P12345" />
        <button class="primary" id="go">Start</button>
      </div>
    </div>
  `);

  document.getElementById("go").onclick = () => {
    const pid = (document.getElementById("pid").value || "").trim();
    if (!pid) { alert("Please enter a participant code."); return; }

    // init real task
    state.pid = pid;
    state.rng = makeRng(pid + "_seed");
    state.order = counterbalance(pid);
    state.shoe = shuffle(makeShoe(4), state.rng);

    state.bankroll = START_BANKROLL;
    state.block = 0;
    state.round = 0;
    state.logs = [];
    state.trust = [];
    state.pending = null;

    // init practice
    state.practiceDone = false;
    state.practiceBankroll = 30;
    state.practiceRng = makeRng(pid + "_practice");
    state.practiceShoe = shuffle(makeShoe(1), state.practiceRng);

    screenTutorialIntro();
  };
}

/* ---------- PRACTICE / TUTORIAL ---------- */
function screenTutorialIntro(){
  render(`
    <div class="card" style="background:#fff;">
      <h2>Practice Round (Tutorial)</h2>
      <p class="muted">
        You will do <strong>1 practice round</strong> to learn the interface. This practice round does <strong>not</strong> count and is <strong>not</strong> included in your data.
      </p>
      <ul class="muted">
        <li><strong>Step 1:</strong> Place a bet first.</li>
        <li><strong>Step 2:</strong> See your cards and the dealer’s up-card.</li>
        <li><strong>Step 3:</strong> See the AI’s suggested action, then choose your own.</li>
        <li><strong>Step 4:</strong> You will always see a result screen (win/loss/push) before continuing.</li>
      </ul>
      <div style="margin-top:12px;">
        <button class="primary" id="startPractice">Start practice</button>
      </div>
    </div>
  `);

  document.getElementById("startPractice").onclick = () => {
    screenPracticeBet();
  };
}

function practiceDraw(){
  if (state.practiceShoe.length < 15) state.practiceShoe = shuffle(makeShoe(1), state.practiceRng);
  return state.practiceShoe.pop();
}

function screenPracticeBet(){
  const aiType = "SAFE";
  const suggestedBet = aiBet(state.practiceBankroll, aiType, state.practiceRng);

  render(`
    <div class="card" style="background:#fff;">
      <div class="row" style="align-items:flex-end;">
        <div>
          <div><strong>Practice</strong> <span class="pill">SAFE AI</span></div>
          <div class="muted">This is a tutorial round only</div>
        </div>
        <div style="text-align:right;">
          <div><strong>Practice bankroll:</strong> ${state.practiceBankroll}</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Place your bet (practice)</h2>
      <p class="muted">Enter a bet, then click <strong>Deal</strong>. The AI’s suggested bet is shown on the right.</p>

      <div class="row">
        <div>
          <label class="muted" for="pbet"><strong>Your bet</strong> (1–${Math.max(1,state.practiceBankroll)})</label><br/>
          <input id="pbet" type="number" min="1" max="${Math.max(1,state.practiceBankroll)}"
                 value="${Math.min(5, Math.max(1,state.practiceBankroll))}"/>
        </div>
        <div style="text-align:right;">
          <div class="muted"><strong>AI suggested bet</strong></div>
          <div style="font-size:18px;"><strong>${suggestedBet}</strong></div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <button class="primary" id="pdeal">Deal</button>
      </div>
    </div>
  `);

  document.getElementById("pdeal").onclick = () => {
    let bet = parseInt(document.getElementById("pbet").value, 10);
    if (!Number.isFinite(bet)) bet = 1;
    bet = Math.max(1, Math.min(bet, Math.max(1,state.practiceBankroll)));

    const playerStart = [practiceDraw(), practiceDraw()];
    const dealerStart = [practiceDraw(), practiceDraw()];
    const dealerUp = dealerStart[0].r;

    const suggestedAction = basicStrategy(playerStart, dealerUp);

    screenPracticeAction(bet, suggestedBet, suggestedAction, playerStart, dealerStart);
  };
}

function screenPracticeAction(bet, aiBetSuggestion, aiActionSuggestion, playerStart, dealerStart){
  render(`
    <div class="card" style="background:#fff;">
      <div class="row" style="align-items:flex-end;">
        <div>
          <div><strong>Practice</strong> <span class="pill">SAFE AI</span></div>
          <div class="muted">Choose an action</div>
        </div>
        <div style="text-align:right;">
          <div><strong>Practice bankroll:</strong> ${state.practiceBankroll}</div>
        </div>
      </div>
    </div>

    <div class="grid2">
      <div class="card">
        <h2>Dealer</h2>
        <div class="hand">${cardStr(dealerStart[0])} <span class="muted">[hidden]</span></div>
      </div>
      <div class="card">
        <h2>You</h2>
        <div class="hand">${handStr(playerStart)}</div>
      </div>
    </div>

    <div class="card">
      <h2>AI Advice (practice)</h2>
      <div class="row">
        <div><strong>Your bet:</strong> ${bet}</div>
        <div><strong>AI suggested action:</strong> ${aiActionSuggestion}</div>
      </div>
      <p class="muted" style="margin-top:8px;">
        In the real task, this repeats each round. Click an action below.
      </p>
      <div class="row">
        <button id="phit">Hit</button>
        <button id="pstand">Stand</button>
        <button id="pdouble">Double</button>
      </div>
      <p class="muted" style="margin:10px 0 0;">Simplified rule: your chosen action is applied once per round.</p>
    </div>
  `);

  const canDouble = (bet*2 <= state.practiceBankroll) && (playerStart.length === 2);
  if (!canDouble) document.getElementById("pdouble").disabled = true;

  const finish = (participantAction) => {
    const bankrollStart = state.practiceBankroll;

    let player = playerStart.slice();
    let dealer = dealerStart.slice();
    let finalBet = bet;

    if (participantAction === "Double" && canDouble){
      finalBet = bet*2;
      player.push(practiceDraw());
    } else if (participantAction === "Hit"){
      player.push(practiceDraw());
    }

    dealer = dealerPlay(dealer, state.practiceShoe);
    const res = resolveOutcome(player, dealer, finalBet);
    state.practiceBankroll += res.delta;

    const kind = res.delta>0 ? "win" : (res.delta<0 ? "loss" : "push");
    const moneyText = (res.delta>0)
      ? `+${res.delta} (bankroll: ${bankrollStart} → ${state.practiceBankroll})`
      : `${res.delta} (bankroll: ${bankrollStart} → ${state.practiceBankroll})`;

    screenFeedback({
      heading: "Practice result",
      kind,
      moneyText,
      playerHand: handStr(player),
      dealerHand: handStr(dealer),
      playerTotal: handTotal(player),
      dealerTotal: handTotal(dealer),
      note: "Practice complete. Next you’ll answer a short question before starting the real task."
    }, () => {
      state.practiceDone = true;
      screenTrust(BASELINE_TRUST_PROMPT, "");
    });
  };

  document.getElementById("phit").onclick = ()=>finish("Hit");
  document.getElementById("pstand").onclick = ()=>finish("Stand");
  document.getElementById("pdouble").onclick = ()=>finish("Double");
}

/* ---------- TRUST ---------- */
function screenTrust(label, aiLabel){
  render(`
    <div class="card">
      <h2>Trust Rating</h2>
      <p>${escapeHtml(label)}</p>
      <p class="muted">1 = very low, 7 = very high</p>
      <div class="row">
        <select id="trust">
          ${[1,2,3,4,5,6,7].map(v=>`<option value="${v}" ${v===4?"selected":""}>${v}</option>`).join("")}
        </select>
        <button class="primary" id="continue">Continue</button>
      </div>
    </div>
  `);

  document.getElementById("continue").onclick = () => {
    const v = parseInt(document.getElementById("trust").value, 10);
    state.trust.push({label, ai: aiLabel, trust_1_7: v});

    if (label.startsWith("Baseline")) {
      // start Block 1 with fresh bankroll
      state.block = 0;
      state.round = 0;
      state.bankroll = START_BANKROLL;
      screenBetFirst();
      return;
    }

    if (label.startsWith("After Block 1")) {
      // Block 2 must start with the same bankroll
      state.block = 1;
      state.round = 0;
      state.bankroll = START_BANKROLL;  // IMPORTANT: reset bankroll for Block 2
      screenBetFirst();
      return;
    }

    if (label.startsWith("After Block 2")) {
      screenEnd();
      return;
    }

    screenEnd();
  };
}

/* ---------- REAL TASK FLOW ---------- */
function screenBetFirst(){
  // If we've completed the block, go to trust immediately
  if (state.round >= ROUNDS_PER_BLOCK){
    if (state.block === 0){
      screenTrust("After Block 1", state.order[0]);
    } else {
      screenTrust("After Block 2", state.order[1]);
    }
    return;
  }

  const aiType = state.order[state.block];
  const bankrollStart = state.bankroll;

  // PRE-DEAL: AI bet advice shown before any cards
  const suggestedBet = aiBet(state.bankroll, aiType, state.rng);

  // Set pending info for this round
  state.pending = {
    aiType,
    bankrollStart,
    suggestedBet,
    participantBetBase: null,
    playerStart: null,
    dealerStart: null,
    suggestedAction: null
  };

  render(`
    ${headerHTML()}

    <div class="card">
      <h2>Place your bet</h2>
      <p class="muted">Bet first. You will see your cards after you click Deal.</p>
      <div class="row">
        <div>
          <label class="muted" for="bet"><strong>Your bet</strong> (1–${Math.max(1,state.bankroll)})</label><br/>
          <input id="bet" type="number" min="1" max="${Math.max(1,state.bankroll)}"
                 value="${Math.min(5, Math.max(1,state.bankroll))}"/>
        </div>
        <div style="text-align:right;">
          <div class="muted"><strong>AI suggested bet</strong></div>
          <div style="font-size:18px;"><strong>${suggestedBet}</strong></div>
        </div>
      </div>
      <div style="margin-top:12px;">
        <button class="primary" id="deal">Deal</button>
      </div>
    </div>
  `);

  document.getElementById("deal").onclick = () => {
    let bet = parseInt(document.getElementById("bet").value, 10);
    if (!Number.isFinite(bet)) bet = 1;
    bet = Math.max(1, Math.min(bet, Math.max(1,state.bankroll)));
    state.pending.participantBetBase = bet;

    // Deal now
    const playerStart = [draw(), draw()];
    const dealerStart = [draw(), draw()];
    const dealerUp = dealerStart[0].r;

    // AI action advice now that hand is known
    const base = basicStrategy(playerStart, dealerUp);
    const suggestedAction = (aiType==="RISKY")
      ? riskyDeviation(playerStart, dealerUp, base, state.rng)
      : base;

    state.pending.playerStart = playerStart;
    state.pending.dealerStart = dealerStart;
    state.pending.suggestedAction = suggestedAction;

    screenActionChoice();
  };
}

function screenActionChoice(){
  const p = state.pending;
  const aiType = p.aiType;
  const playerStart = p.playerStart;
  const dealerStart = p.dealerStart;

  const canDouble = (p.participantBetBase * 2 <= state.bankroll) && (playerStart.length === 2);

  render(`
    ${headerHTML()}

    <div class="grid2">
      <div class="card">
        <h2>Dealer</h2>
        <div class="hand">${cardStr(dealerStart[0])} <span class="muted">[hidden]</span></div>
      </div>
      <div class="card">
        <h2>You</h2>
        <div class="hand">${handStr(playerStart)}</div>
      </div>
    </div>

    <div class="card">
      <h2>AI Advice</h2>
      <div class="row">
        <div><strong>Your bet:</strong> ${p.participantBetBase}</div>
        <div><strong>AI suggested action:</strong> ${p.suggestedAction}</div>
      </div>
      <p class="muted" style="margin-top:8px;">Now choose your action.</p>
      <div class="row">
        <button id="hit">Hit</button>
        <button id="stand">Stand</button>
        <button id="double" ${canDouble ? "" : "disabled"}>Double</button>
      </div>
      <p class="muted" style="margin:10px 0 0;">Simplified rule: your chosen action is applied once per round.</p>
      ${canDouble ? "" : `<p class="muted" style="margin:10px 0 0;">Double is unavailable (needs enough bankroll and exactly 2 cards).</p>`}
    </div>
  `);

  const finishRound = (participantAction) => {
    let player = playerStart.slice();
    let dealer = dealerStart.slice();

    const bankrollStart = p.bankrollStart;
    let finalBet = p.participantBetBase;

    if (participantAction === "Double" && canDouble){
      finalBet = finalBet*2;
      player.push(draw());
    } else if (participantAction === "Hit"){
      player.push(draw());
    }

    dealer = dealerPlay(dealer, state.shoe);
    const res = resolveOutcome(player, dealer, finalBet);
    state.bankroll += res.delta;

    const playerTot = handTotal(player);
    const dealerTot = handTotal(dealer);

    const kind = res.delta>0 ? "win" : (res.delta<0 ? "loss" : "push");
    const moneyText = (res.delta>0)
      ? `+${res.delta} (bankroll: ${bankrollStart} → ${state.bankroll})`
      : `${res.delta} (bankroll: ${bankrollStart} → ${state.bankroll})`;

    // Log (REAL task only)
    state.logs.push({
      pid: state.pid,
      block_order: state.order.join("-"),
      block_ai: aiType,
      block_number: state.block+1,
      round_in_block: state.round + 1,
      bankroll_start: bankrollStart,
      bankroll_end: state.bankroll,
      ai_bet: p.suggestedBet,
      participant_bet: finalBet,
      bet_followed_ai: (finalBet === p.suggestedBet) ? 1 : 0,
      ai_action: p.suggestedAction,
      participant_action: participantAction,
      action_followed_ai: (participantAction === p.suggestedAction) ? 1 : 0,
      player_start_hand: handStr(playerStart),
      player_final_hand: handStr(player),
      dealer_upcard: cardStr(dealerStart[0]),
      dealer_final_hand: handStr(dealer),
      player_total: playerTot,
      dealer_total: dealerTot,
      outcome: res.outcome,
      delta: res.delta,
      t: new Date().toISOString()
    });

    // Clear pending and move to feedback screen (always shows, including last round)
    state.pending = null;

    screenFeedback({
      heading: `Round ${state.round + 1} result`,
      kind,
      moneyText,
      playerHand: handStr(player),
      dealerHand: handStr(dealer),
      playerTotal: playerTot,
      dealerTotal: dealerTot
    }, () => {
      // Advance to next round AFTER the participant sees feedback
      state.round += 1;
      screenBetFirst();
    });
  };

  document.getElementById("hit").onclick = ()=>finishRound("Hit");
  document.getElementById("stand").onclick = ()=>finishRound("Stand");
  document.getElementById("double").onclick = ()=>{ if (canDouble) finishRound("Double"); };
}

/* ---------- END + PACKAGE ---------- */
function screenEnd(){
  const code = completionCodeFrom(state.pid);
  const payloadObj = {
    version: "blackjack_ai_v3_practice_blockreset_feedbackscreen_baselinetrust_aiwording",
    pid: state.pid,
    completion_code: code,
    order: state.order,
    trust: state.trust,
    trials: state.logs
  };

  const jsonString = JSON.stringify(payloadObj);

  // Use compressed package by default
  const payloadB64_zip = LZString.compressToBase64(jsonString);
  const payloadB64 = payloadB64_zip;

  render(`
    <div class="card" style="background:#fff;">
      <h2>Finished</h2>
      <p><strong>Completion code:</strong> <code>${code}</code></p>
      <p class="muted">Return to Experimentum and paste the data package below into the textbox.</p>
    </div>

    <div class="card">
      <h2>DATA PACKAGE</h2>
      <textarea id="pkg" readonly>${payloadB64}</textarea>
      <div class="row">
        <button class="primary" id="copy">Copy data package</button>
      </div>
      <p class="muted">If copying fails, select all text and copy manually (Ctrl/Cmd+C).</p>
    </div>
  `);

  document.getElementById("copy").onclick = async () => {
    const txt = document.getElementById("pkg").value;
    try {
      await navigator.clipboard.writeText(txt);
      alert("Copied. Now paste into Experimentum.");
    } catch {
      alert("Copy failed. Please copy manually (Ctrl/Cmd+C).");
    }
  };
}

/* Start */
screenStart();
</script>
</body>
</html>
